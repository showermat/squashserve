#![feature(decl_macro)]

extern crate itertools;
extern crate liquid;
extern crate owning_ref;
#[macro_use] extern crate rocket;
#[macro_use] extern crate serde_json;
extern crate squashfs;

mod library;

use std::collections::{BTreeMap, HashMap};
use std::convert::TryInto;
use std::io::{Cursor, Read};
use std::net::SocketAddr;
use std::path::{Path, PathBuf};
use std::sync::{Arc, RwLock};
use library::{content_type, Library, Volume};
use itertools::Itertools;
use liquid::Parser;
use liquid::partials::{InMemorySource, LazyCompiler};
use owning_ref::OwningHandle;
use regex::Regex;
use rocket::config::{Config as RocketConfig, Environment};
use rocket::http::{ContentType, Status};
use rocket::http::uri::{Formatter, FromUriParam, Path as UriPath, Query as UriQuery, SegmentError, Segments, Uri, UriDisplay};
use rocket::outcome::Outcome;
use rocket::request::{FromQuery, FromSegments, Query, Request};
use rocket::response::{Redirect, Responder, Stream};
use rocket::response::content::{Content, Html, Json};
use rocket::State;
use serde::{Deserialize, Serialize};
use squashfs::read::{Archive, Data, Dir, Node, OwnedFile, XattrType};
use thiserror::Error;

const APPNAME: &str = "sqsrv";

// TODO Squashfs errors (both StartupError and AppError) don't capture the path of the volume that
// has the problem.  Figure out the least painful way to make that information available --
// probably in the squashfs lib.
#[derive(Error, Debug)]
pub enum StartupError {
	#[error("Invalid program configuration: {0}")] Config(#[from] serde_yaml::Error),
	#[error("Failed to load library: {0}")] LibraryLoad(#[from] library::LoadError),
	#[error("Failed to initialize template parser: {0}")] Template(#[from] liquid::Error),
	#[error("Error reading content from archive file: {0}")] Squashfs(#[from] squashfs::SquashfsError),
	#[error("Failed to start server: {0}")] Server(#[from] rocket::config::ConfigError),
	#[error("Error reading from file system: {0}")] Io(#[from] std::io::Error),
	#[error("Unable to load default category in library: {0}")] CategoryLoad(AppError), // Intentionally not autoconverting
}

#[derive(Error, Debug)]
pub enum AppError {
	#[error("Error reading content from archive file: {0}")] Squashfs(#[from] squashfs::SquashfsError),
	#[error("Requested volume {0} does not exist")] NoVolume(String),
	#[error("The requested path {1} does not exist in volume {0}")] NoFile(String, PathBuf),
	#[error("The `home` property of volume {0} is unset or misset, and autogenerated indices are disabled")] NoHome(String),
	#[error("Volume {0} does not have a root node")] NoRoot(String),
	#[error("Required resource {0} is not present in the resources archive")] NoResource(PathBuf),
	#[error("Category \"{0}\" does not exist")] NoCategory(String),
	#[error("No file matching the constraints exists in the volume")] NoMatch,
	#[error("Unable to determine content type for object at {0}: {1}")] ContentType(PathBuf, String),
	#[error("Path {1} in volume {0} is a(n) {2} and cannot be served")] FileType(String, PathBuf, String),
	#[error("Volume {0} does not support searching")] Unsearchable(String),
	#[error("You are not authorized to access this resource")] Unauthorized,
	#[error("Template error: {0}")] Template(#[from] liquid::Error),
	#[error("Couldn't convert a value to JSON: {0}")] JsonConversion(#[from] serde_json::Error),
	#[error("Search index bug or corruption: {0}")] Search(#[from] disktree::Error),
	#[error("Invalid UTF-8: {0}")] Utf8(#[from] std::string::FromUtf8Error), // TODO This needs some context
	#[error("Failed to load library: {0}")] LibraryLoad(#[from] library::LoadError),
}

impl AppError {
	fn status(&self) -> Status {
		match self {
			AppError::Squashfs(_) => Status::InternalServerError,
			AppError::NoVolume(_) => Status::NotFound,
			AppError::NoFile(_, _) => Status::NotFound,
			AppError::NoHome(_) => Status::NotFound,
			AppError::NoRoot(_) => Status::NotFound,
			AppError::NoResource(_) => Status::InternalServerError,
			AppError::NoCategory(_) => Status::NotFound,
			AppError::NoMatch => Status::NotFound,
			AppError::ContentType(_, _) => Status::InternalServerError,
			AppError::FileType(_, _, _) => Status::BadRequest,
			AppError::Unsearchable(_) => Status::BadRequest,
			AppError::Unauthorized => Status::Unauthorized,
			AppError::Template(_) => Status::InternalServerError,
			AppError::JsonConversion(_) => Status::InternalServerError,
			AppError::Search(_) => Status::InternalServerError,
			AppError::Utf8(_) => Status::InternalServerError,
			AppError::LibraryLoad(_) => Status::InternalServerError,
		}
	}
}

impl<'a> Responder<'a> for AppError {
	fn respond_to(self, request: &Request) -> rocket::response::Result<'a> {
		let status = self.status();
		let body = match request.guard::<State<App>>() {
			Outcome::Success(app) => app.template("error", &json!({"header": status.reason, "message": self.to_string()})).unwrap(),
			_ => format!("<html><title>{}</title></head></body><h1>{}</h1><p>{}.</p></body></html>", status.reason, status.reason, self.to_string()),
		};
		rocket::response::Response::build()
			.status(status)
			.header(ContentType::HTML)
			.sized_body(Cursor::new(body))
			.ok()
	}
}

type Result<T> = std::result::Result<T, AppError>;

type StartupResult<T> = std::result::Result<T, StartupError>;

struct UncheckedPath {
	path: PathBuf,
}

impl UncheckedPath {
	fn get(self) -> PathBuf {
		self.path
	}
}

impl<'a> FromSegments<'a> for UncheckedPath {
	type Error = SegmentError;

	fn from_segments(segments: Segments<'a>) -> std::result::Result<Self, Self::Error> {
		let mut ret = PathBuf::new();
		for segment in segments {
			let decoded = Uri::percent_decode(segment.as_bytes()).map_err(SegmentError::Utf8)?;
			if decoded == ".." { ret.pop(); }
			else if decoded.contains("/") { return Err(SegmentError::BadChar('/')); }
			else { ret.push(&*decoded); }
		}
		Ok(Self { path: ret })
	}
}

impl UriDisplay<UriPath> for UncheckedPath {
	fn fmt(&self, f: &mut Formatter<UriPath>) -> std::fmt::Result {
		self.path.fmt(f)
	}
}

impl FromUriParam<UriPath, PathBuf> for UncheckedPath {
	type Target = Self;

	fn from_uri_param(path: PathBuf) -> UncheckedPath {
		UncheckedPath { path: path }
	}
}

struct QueryMap {
	items: HashMap<String, String>,
}

impl QueryMap {
	fn get(self) -> HashMap<String, String> {
		self.items
	}
}

impl FromQuery<'_> for QueryMap {
	type Error = std::str::Utf8Error;

	fn from_query(query: Query) -> std::result::Result<Self, Self::Error> {
		let mut items = HashMap::new();
		for item in query {
			let (k, v) = item.key_value();
			items.insert(k.percent_decode()?.to_string(), v.percent_decode()?.to_string());
		}
		Ok(Self{ items: items })
	}
}

impl UriDisplay<UriQuery> for QueryMap {
	fn fmt(&self, f: &mut Formatter<UriQuery>) -> std::fmt::Result {
		unimplemented!();
	}
}

impl FromUriParam<UriQuery, HashMap<String, String>> for QueryMap {
	type Target = Self;

	fn from_uri_param(map: HashMap<String, String>) -> QueryMap {
		Self { items: map }
	}
}

#[derive(Debug, Deserialize)]
struct SslConfig {
	cert: String,
	key: String,
}

#[derive(Debug, Deserialize)]
pub struct CategoryConfig {
	name: String,
	volumes: Vec<String>,
}

#[derive(Debug, Deserialize)]
#[serde(default = "Config::default")]
struct Config {
	basedir: PathBuf,
	port: u16,
	resources: PathBuf,
	listen: String,
	complete: u32,
	title_results: u32,
	toolbar: bool,
	indices: bool,
	ssl: Option<SslConfig>,
	categories: Vec<CategoryConfig>,
}

impl Config {
	fn default() -> Self {
		Self {
			basedir: PathBuf::from("."),
			port: 2234,
			resources: PathBuf::from("./resources.sfs"),
			listen: "127.0.0.1".to_string(),
			complete: 40,
			title_results: 100,
			toolbar: true,
			indices: false,
			ssl: None,
			categories: Vec::new(),
		}
	}

	fn new() -> StartupResult<Self> {
		let custom_var = APPNAME.to_uppercase() + "_CONF";
		let subpath = Path::new(APPNAME).join(APPNAME.to_string() + ".yaml");
		let fallback: Vec<Box<Fn() -> std::result::Result<PathBuf, std::env::VarError>>> = vec![
			Box::new(|| Ok(PathBuf::from(&std::env::var(&custom_var)?))),
			Box::new(|| Ok(Path::new(&std::env::var("XDG_CONFIG_HOME")?).join(&subpath))),
			Box::new(|| Ok(Path::new(&std::env::var("HOME")?).join(".config").join(&subpath))),
			Box::new(|| Ok(Path::new("/home").join(std::env::var("USER")?).join(".config").join(&subpath))),
			Box::new(|| Ok(Path::new("/etc").join(&subpath))),
		];
		for test in fallback {
			if let Ok(path) = test() {
				if let Ok(reader) = std::fs::File::open(path) {
					return Ok(serde_yaml::from_reader(reader)?)
				}
			}
		}
		return Ok(Self::default());
	}
}

struct App {
	resources: Archive,
	config: Config,
	library: RwLock<Library>,
	parser: Parser,
}

impl App {
	fn library(&self) -> std::sync::RwLockReadGuard<Library> {
		self.library.read().expect("Poisoned lock")
	}

	fn library_mut(&self) -> std::sync::RwLockWriteGuard<Library> {
		self.library.write().expect("Poisoned lock")
	}

	fn resource<T: AsRef<Path>>(&self, path: T) -> Result<(OwnedFile, ContentType)> {
		let pathbuf = path.as_ref().to_path_buf();
		let node = self.resources.get(&path)?.ok_or(AppError::NoResource(pathbuf))?;
		let ctype = content_type(&node)?;
		Ok((node.into_owned_file()?, ctype))
	}

	fn template<T: Serialize>(&self, template: &str, t: &T) -> Result<String> {
		let values = liquid::to_object(t)?;
		let source = self.resource(&format!("html/{}.html", template))?.0.to_string()?;
		Ok(self.parser.parse(&source)?.render(&values)?)
	}

	fn viewbase(&self) -> &str {
		match self.config.toolbar {
			true => "/view",
			false => "/content",
		}
	}
}

pub struct ReadHandle<'a> {
	handle: OwningHandle<Arc<Volume>, OwnedFile<'a>>,
}

impl<'a> std::io::Read for ReadHandle<'a> {
	fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
		(*self.handle).read(buf)
	}
}

#[derive(Responder)]
enum Response<'a> {
	Stream(Content<Stream<ReadHandle<'a>>>),
	Redirect(Redirect),
	Html(Html<String>),
	Json(Json<String>),
}

impl<'a> Response<'a> {
	fn redirect<T: TryInto<Uri<'static>>>(to: T) -> Self {
		Self::Redirect(Redirect::to(to))
	}

	fn html(s: String) -> Self {
		Self::Html(Html(s))
	}

	fn json<T: Serialize + ?Sized>(t: &T) -> Result<Self> {
		Ok(Self::Json(Json(serde_json::to_string(t)?)))
	}
}

#[derive(Debug, Serialize)]
struct TitleEntry {
	title: String,
	url: PathBuf
}

#[derive(Debug, Serialize)]
struct IndexEntry {
	name: String,
	kind: String,
	link: bool,
	mime: String,
	size: String,
}

#[get("/rsrc/<path..>")]
fn rsrc(app: State<App>, path: UncheckedPath) -> Result<Content<Vec<u8>>> {
	let (mut file, ctype) = app.resource(&path.get())?;
	Ok(Content(ctype, file.to_bytes()?))
}

#[get("/")]
fn home(app: State<App>, remote_ip: Option<SocketAddr>) -> Result<Response> {
	let local = remote_ip.map(|x| x.ip().is_loopback()).unwrap_or(false);
	Ok(Response::html(app.template("home", &json!({"priv": local, "viewbase": app.viewbase(), "categories": app.library().tokens()?}))?))
}

fn index<'a>(app: State<'a, App>, volume: &Volume, pathbuf: &PathBuf, dir: Dir) -> Result<Response<'a>> {
	let mut entries = dir.map(|child| {
		let resolved = child.resolve()?;
		let data = resolved.data()?;
		Ok(IndexEntry {
			name: child.name().unwrap_or("(unknown)".to_string()),
			mime: content_type(&resolved).map(|x| x.to_string()).unwrap_or("".to_string()),
			kind: data.name(),
			link: match child.data()? {
				Data::Symlink(_) => true,
				_ => false,
			},
			size: match data {
				Data::File(file) => bytesize::ByteSize::b(file.size()).to_string_as(true),
				Data::Dir(dir) => dir.count().to_string(),
				_ => "".to_string(),
			},
		})
	}).collect::<Result<Vec<IndexEntry>>>()?;
	entries.sort_by_key(|x| x.name.clone());
	if pathbuf.parent().is_some() {
		entries.insert(0, IndexEntry {
			name: "..".to_string(),
			kind: "up".to_string(),
			link: false,
			mime: "".to_string(),
			size: "".to_string(),
		});
	}
	let name = match pathbuf.file_name().unwrap_or(pathbuf.as_os_str()).to_string_lossy().to_string().as_ref() {
		"" => "/".to_string(),
		path => path.to_string(),
	};
	Ok(Response::html(app.template("index", &json!({"viewbase": app.viewbase(), "volume": volume.info().string_values(), "path": pathbuf, "tail": name, "entries": entries}))?))
}

#[get("/content/<id>/<path..>")]
fn content<'a>(app: State<'a, App>, id: String, path: UncheckedPath) -> Result<Response<'a>> {
	let pathbuf = path.get();
	let volume = app.inner().library().get(&id)?;
	match (*volume).get(&pathbuf)? {
		None => Err(AppError::NoFile(id, pathbuf))?,
		Some(node) => {
			match node.resolve()?.data()? {
				Data::File(_) => {
					let ctype = content_type(&node)?;
					let conv = |vol: *const Volume| -> Result<OwnedFile<'a>> { unsafe { Ok((*vol).get(&pathbuf)?.unwrap().into_owned_file()?) } }; // This needs some work!
					let read = ReadHandle { handle: OwningHandle::try_new(volume, conv)? };
					Ok(Response::Stream(Content(ctype, Stream::from(read))))
				},
				//Data::Symlink(target) => Ok(Response::redirect(uri!(content: id, PathBuf::from(target)))),
				Data::Dir(dir) => {
					match app.config.indices {
						true => Ok(index(app, &volume, &pathbuf, dir)?),
						false => Err(AppError::NoFile(id, pathbuf))?,
					}
				},
				_ => Err(AppError::FileType(id, pathbuf, node.data()?.name()))?,
			}
		},
	}
}

#[get("/content/<id>")]
fn content_default<'a>(app: State<'a, App>, id: String) -> Result<Response<'a>> {
	let vol = app.inner().library().get(&id)?;
	match app.config.indices {
		true => match vol.get(&Path::new(""))? {
			Some(root) => Ok(index(app, &vol, &PathBuf::new(), root.as_dir()?)?),
			None => Err(AppError::NoRoot(id))?,
		},
		false => match &vol.info().home {
			Some(home) => Ok(Response::redirect(uri!(content: id, home.clone()))),
			None => Err(AppError::NoHome(id))?,
		},
	}
}

#[get("/view/<id>/<path..>?<query..>")]
fn view<'a>(app: State<'a, App>, id: String, path: UncheckedPath, query: Option<QueryMap>) -> Result<Response<'a>> {
	match app.config.toolbar {
		true => {
			let pathstr = path.get().as_os_str().to_str().expect("Non-UTF-8 request path").to_string();
			let info = app.library().get(&id)?.info().string_values();
			let live = match info.get("origin") {
				Some(origin) => {
					match origin.split(";").collect::<Vec<&str>>()[..] {
						[base, pattern, replacement] => match Regex::new(pattern) {
							Ok(re) => Some(base.to_string() + &re.replace_all(&pathstr, replacement)),
							Err(_) => None,
						},
						_ => None,
					}
				}
				None => None,
			};
			let querybody = match query {
				Some(map) => map.get().into_iter().map(|(k, v)| format!("{}={}", Uri::percent_encode(&k), Uri::percent_encode(&v))).join("&"),
				None => "".to_string(),
			};
			let querystr = match querybody.as_str() {
				"" => "".to_string(),
				q => "?".to_string() + q,
			};
			Ok(Response::html(app.template("view", &json!({"volume": info, "path": pathstr, "query": querystr, "live": live}))?))
		},
		false => Ok(Response::redirect(uri!(content: id, path.get()))),
	}
}

#[get("/view/<id>")]
fn view_default<'a>(app: State<'a, App>, id: String) -> Result<Response<'a>> {
	view(app, id, UncheckedPath { path: PathBuf::new() }, None)
}

#[get("/titles/<id>?<q>&<p>")]
fn titles<'a>(app: State<'a, App>, id: String, q: String, p: Option<u32>) -> Result<Response<'a>> {
	let vol = app.library().get(&id)?;
	let page = std::cmp::max(p.unwrap_or(1), 1);
	match vol.titles(&q, page, app.config.title_results)? {
		None => Err(AppError::Unsearchable(id))?,
		Some((pages, res)) => {
			let full_res = res.into_iter().map(|(k, v)| TitleEntry { title: k, url: v }).collect::<Vec<_>>();
			Ok(Response::html(app.template("titles", &json!({"pages": pages, "page": page, "query": q, "viewbase": app.viewbase(), "volume": vol.info().string_values(), "results": full_res}))?))
		},
	}
}

#[get("/complete/<id>?<q>")]
fn complete<'a>(app: State<'a, App>, id: String, q: String) -> Result<Response<'a>> {
	match app.inner().library().get(&id)?.titles(&q, 1, app.config.complete)? {
		None => Ok(Response::json("[]")?),
		Some((pages, res)) => {
			let mut ret = res.into_iter().map(|(k, v)| TitleEntry { title: k, url: PathBuf::from("/view").join(&id).join(v) }).collect::<Vec<_>>();
			ret.push(TitleEntry { title: "<b>See all</b>".to_string(), url: PathBuf::from(uri!(titles: id, q, 1).to_string()) });
			Ok(Response::json(&ret)?)
		},
	}
}

#[get("/search/<id>?<q>")]
fn search<'a>(app: State<'a, App>, id: String, q: String) -> Result<Response<'a>> {
	let vol = app.library().get(&id)?;
	match vol.exact_title(&q)? {
		Some(path) => Ok(Response::redirect(uri!(view: id, path, _))),
		None => match vol.titles(&q, 1, 1)? {
			Some((1, res)) => Ok(Response::redirect(uri!(view: id, res.into_iter().next().expect("Can't get item from non-empty iterator").1, _))),
			_ => Ok(Response::redirect(uri!(titles: id, q, 1))),
		},
	}
}

#[get("/shuffle/<id>")]
fn shuffle<'a>(app: State<'a, App>, id: String) -> Result<Response<'a>> {
	let vol = app.library().get(&id)?;
	match vol.random(ContentType::HTML)? {
		Some(path) => Ok(Response::redirect(uri!(view: id, path, _))),
		None => Err(AppError::NoMatch)?,
	}
}

#[get("/load?<cat>")]
fn load<'a>(app: State<'a, App>, cat: String) -> Result<Response<'a>> {
	let volume_tokens = app.library().load(&cat)?.volumes;
	Ok(Response::html(app.template("part/volume-rows", &json!({"viewbase": app.viewbase(), "volumes": volume_tokens}))?))
}

#[get("/unload?<cat>")]
fn unload<'a>(app: State<'a, App>, cat: String) -> Result<Response<'a>> {
	app.library().unload(&cat);
	Ok(Response::html("".to_string()))
}

#[get("/external?<path>")]
fn external<'a>(app: State<'a, App>, path: String, remote_ip: Option<SocketAddr>) -> Result<Response<'a>> {
	let local = remote_ip.map(|x| x.ip().is_loopback()).unwrap_or(false);
	if !local { Err(AppError::Unauthorized)?; }
	let id = app.library().load_external(&Path::new(&path))?;
	Ok(Response::redirect(uri!(view: id, PathBuf::new(), _)))
}

#[get("/action/refresh")]
fn refresh<'a>(app: State<'a, App>) -> Result<Response<'a>> {
	*app.library_mut() = Library::new(&app.config.basedir, &app.config.categories)?;
	Ok(Response::redirect(uri!(home)))
}

#[get("/action/quit")]
fn quit<'a>(app: State<'a, App>, remote_ip: Option<SocketAddr>) {
	let local = remote_ip.map(|x| x.ip().is_loopback()).unwrap_or(false);
	// TODO Can I send a response and then exit?
	if local { std::process::exit(0); }
}

fn run() -> StartupResult<()> {
	let config = Config::new()?;
	let library = Library::new(&config.basedir, &config.categories)?;
	let resources = Archive::new(&config.resources)?;
	let mut partials = InMemorySource::new();
	if let Some(partdir) = resources.get("html/part")? {
		for file in partdir.resolve()?.as_dir()? {
			let resolved = file.resolve()?;
			if resolved.is_file()? {
				let name = file.path().expect("No path for file retrieved by path").file_stem().expect("No file name for non-root").to_str().unwrap().to_string();
				let mut content = String::new();
				resolved.as_file()?.read_to_string(&mut content)?;
				partials.add(name, content);
			}
		}
	}
	let parser = liquid::ParserBuilder::with_stdlib().partials(LazyCompiler::new(partials)).build()?;
	let app = App {
		resources: resources,
		config: config,
		library: RwLock::new(library),
		parser: parser,
	};
	let rocket_conf = RocketConfig::build(Environment::Development)
		.address(app.config.listen.clone())
		.port(app.config.port);
	let rocket_conf = match &app.config.ssl {
		Some(ssl) => rocket_conf.tls(ssl.cert.clone(), ssl.key.clone()),
		None => rocket_conf,
	};
	rocket::custom(rocket_conf.finalize()?)
		.manage(app)
		.mount("/", routes![content, content_default, home, quit, rsrc, view, view_default, titles, complete, search, shuffle, load, unload, refresh, external])
		.launch();
	Ok(())
}

fn main() {
	if let Err(e) = run() {
		println!("Error: {}", e)
	}
}
